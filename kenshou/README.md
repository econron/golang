base62が衝突しないか三時間くらい外出ている間に頑張ってもらう。
----

ステップ1：なぜIDを「2種類」に分けるのか？（目的）
まずは「IDを1つで済まそうとするから悩むんだ」という前提を壊します。

内部ID（PKey）： データベースが「速く動く」ためのもの。連番が最強。

公開ID（Public ID）： ユーザーに「推測されない」ためのもの。ランダムな文字列。

結論： 「スピード担当」と「セキュリティ担当」を分けるのが一番賢い。 ### ステップ2：なぜ「連番」が速くて、「UUID」は重いのか？（性能） ここを「空間効率」という言葉を使わずに説明します。

連番は「整理整頓された本棚」： 1, 2, 3...と並んでいるので、DBはどこに何があるかすぐ分かるし、隙間なく本（データ）を詰め込める。

UUIDは「バラバラに届く巨大な荷物」： どこに置けばいいか毎回迷うし、荷物がデカい（128bit）から本棚がすぐいっぱいになって、探すのも遅くなる。

結論： データが小さくて並んでいるほど、メモリにたくさん載るから速い。

ステップ3：なぜ「64bit（16文字）」で十分なのか？（確率）
ここで「誕生日問題」を「くじ引き」に例えて話します。

「誰かと誰かが被る」確率： クラスに23人いれば誕生日が被るペアがいるのと同じで、IDが短いと「システム全体で重複」が起きやすくなる。でも、64bitという空間は「1,800京」もある。1日2万件くらいなら、1万年経ってもまず被らない。

「特定のIDを当てる」確率： 攻撃者があなたのIDを狙い撃ちで当てるのは、何億枚もある宝くじから特定の1枚を当てるより難しい。

結論： 「絶対に被らない長さ」と「扱いやすい短さ」の絶妙なバランスが64bit（Hex16文字）。

https://x.com/yamaz/status/2017348523428352170?s=20

https://x.com/kenn/status/2017066984291389867?s=20

## mac M1のOS thread vs goroutine

Ping-Pongベンチマークを利用する。

- 2つの実行ユニットの間でデータを往復させ、コンテキストスイッチを発生させて時間を計測する。

% go test -bench . -benchtime=5s                              
goos: darwin
goarch: arm64
pkg: kenshou
cpu: Apple M1
BenchmarkGoroutineContextSwitch-8       21138057               261.1 ns/op
BenchmarkOSThreadContextSwitch-8          415213             14737 ns/op
PASS
ok      kenshou 12.539s


効率的なGoだと
- スレッド間のコンテキストスイッチは12000cpuサイクル
- goroutine間のコンテキストスイッチは2400cpuサイクル

みたいに書いてあったけどなんか差がエグすぎるな