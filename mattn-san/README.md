## 今回利用した教材

https://levtech.jp/media/article/column/detail_767/

## 課題

basestacks配下を参照しながらやる

### base1.go

main関数では5つのファイル更新処理を逐次実行している。

しかしこれ自体は並列に処理できるワークフローである（今回はそれぞれが独立した処理と仮定している）

### base2.go

よってgo funcでupdateFileを実行する形式にする。

ただ、goをつけただけだと「メインの処理がgoroutineの終了を待ってない」ので、全て処理されずに処理が終わる。

よってwaitGroupを利用する。

## base3.go

ミニコラムで忘れた用語とかが出てきたので復習がてらメモ

- タイムスライス：osが複数のスレッドにcpuを公平に貸し出すことを目的として割り当てる「待ち時間」
- cpuを割り当てる：電気を流すことではない。コンテキストスイッチの準備作業に等しいと思われる。
- コンテキストスイッチの準備作業をざっくり
  - 今の状態を保存する：現在実行中の計算データ（レジスタの値やスタックポインタ）をメモリに書き出す
  - 次に動かすスレッドのデータをメモリから読み出してcpuのレジスタにセットする
  - cpuのプログラムカウンタをそのスレッドの続きの命令に書き換えて処理を再開する

なぜ動かないスレッドへのcpu割り当ては無駄なのか？

- 管理コストが高い：osは定期的にスレッドの状態をチェックしてキューを管理している。つまりこれだけでcpuが動いてる
- コンテキストスイッチの浪費：移行してもネットワークやファイルのIO待ちだったら次のスレッドに行くが、その際にコンテキストスイッチは出てくる。
- メモリの壁：osはスレッドを1つ作る毎に1MB~2MBの固定スタック領域を確保する。つまり1000個確保したら1~2GB。メモリが不足するとディスクスワップが起きる（あかん）

goのランタイムはスレッドの初期化時のようにごそっとメモリを確保するのではなく、スレッドをいくつか取得してから、2kb割り当てて必要に応じて拡張していく方式で独自に管理している。

## base4

実際にジョブワーカーを実装する。

- ワーカー：決まった処理を繰り返し実行する役目を持ったコンポーネント
- ジョブワーカー：大体はキューからジョブを取得してジョブに対して処理を行う。goではchannelがこの役目を負う。

channelを使ってジョブをキューイングし、channelからジョブを取得して処理を実行する。

```go
type Job struct {

}

type Result struct {

}

func processJob(job Job) Result {
  return Result()
}

func worker(ch <-chan Job, results chan<- Result) {
  for job := range ch {
    result := processJob(ch)
    results <- result
  }
}
```

## 落ちないジョブワーカー設計のポイント

- 適切に処理を分割する
- 並行処理の間をchannelで接続する
- 要件に合わせchannelのバッファサイズを調整する
- contextを使ってキャンセル処理を正しく実装する

1,2はできそう。3,4はできないかな。

## お題

複数の画像URLを受け取り、各画像をダウンロードし、ローカルのテンプレート画像と合成してから、S3や外部ストレージにアップロードする。
